{"title":"Primeiros passos","markdown":{"headingText":"Primeiros passos","containsRefs":false,"markdown":"\n\n`Rworkspace/python`\n\n`py-basic.py`\n\n```{python}\n#| eval: false\n#| echo: true\n#| code-fold: true\n\n# class 01 \n# 2019-07-15\n# Pietro Basttiston\n\n# ------------------------------\n# importar bibliotecas\n\n# importar pandas e para acessar qq função fazer pandas.read_csv()\nimport pandas\n\n# importa com um apelido\n# para acessar as funções fazer: np_read.csv()\nimport pandas as pd\n\n# importa todos os objetos do pacote pandas, inclusive funções intermediárias\n# não precisar de pandas para acessar a função, exemplo: read_csv()\nfrom pandas import *\n\n# importar apenas uma função específica\n# importar apenas read_csv de pandas, mantém o namespace limpo\nfrom pandas import read_csv\n\n# o conceito de funções é chamado de module\n# criar uma pasta com códigos de python com a pasta __init__py\n# todas as funções .py serão importadas\n\n# para fazer deteach() equivalente R\n# deixar de considerar as funções de determinada library\ndel(pd)\n\n# ------------------------------\n# help \n\n# python original help\nhelp(len)\n\n# ipython help\nlen?\n\n# This notation works for just about anything, including object methods\n# equivalente ao c() do R\nL = [1, 2, 3]\nL.insert?\n\n# or even objects themselves\nL?\n\n# this will even work for functions or other objects you create yourself! \ndef square(a):\n     \"Return the square of a.\"\n     return a ** 2\n\nsquare?\n\n# Accessing Source Code with `??`\n\nsquare??\n\n# código em C, não mostra muita coisa\nlen??\n\n# ------------------------------\n# python version\n\nfrom platform import python_version\npython_version()\n\n# ------------------------------\n# comments\n\n# comentário simples com '#'\n\n\"\"\"\ncomment in \nmultiple \nlines\n\"\"\"\n\n\"\"\" pode ser utilizado tb para escerver \nstrings in múltiplas linhas \"\"\"\n\n# ------------------------------\n# strings multiplication\n\n# + é igual concatenar a string\n\nnyname = \"Roney\"\n\nnyname + nyname\n\n# não funciona\nnyname * nyname\n\n# ------------------------------\n# increment \n\n# i += i +1\n\na = 5\na += 1\na\n\nb = 5\nb += b\nb\n\nname = 'Ivette'\nname *= 3\nname\n\n# ------------------------------\n# functions\n\nprint(a)\n\nlen(name)\n\n\n# ------------------------------\n# fundamentals structures\n\n# list\nl = [1,3,5]\nl\n\nl[0]\n\n# contando do final para o início\nl[-2]\n\nlist(name)\nname[0]\nname[1]\n\n\n# ------------------------------\n# object oriented programming \n\n# atributtes\n# methods\n## class\n\nl.append(100)\n\n# encontrar o índice específico\nl.index(3)\nl.index(100)\n\n# adicionar lista na lista\nl.extend([4,6,8,10])\n\n# adicionar 200 na posição 3\nl.insert(3,200)\n\n# listas podem hospedar diferentes tipos de dados\nl.append('Roney')\nl\ntype(l[0])\ntype(l[9])\n\n\n# ------------------------------\n# arguments in functions\n\nb = 'teste'\nprint(a,b, sep=\",\")\n\n# ------------------------------\n# dicts\n# {Chave1 : Valor1, Chave2:Valor2}\n\n# lista com rótulos = `Dictionaries`\n# começam com `{}` a ordem dos valores não é mantida\n\nlanguage = {'Pietro':'Python','Ivette':'R','Tania':'Stata'}\nlanguage\nlanguage['Ivette']\n\n# pode hospedar qq coisa\nlanguage = {'Pietro':'Python','Ivette':'R','Tania':'Stata',2:5}\n\n# converter as chaves em lista\nlist(language)\n\n# olhar para valores\nlanguage.values()\n\n\n# ------------------------------\n# tuple\n\n# um tipo de lista que permite alteração dos elementos \n\n# esse tipo é muito útil para construir dicionários \n# inicia com ()\n\nt = (1,2,3)\n\nlen(t)\n\nt[-1]\n\n# funciona\nt + t\nt * 3\n\na = [1,2,3]\na * 3\n\n\n# ------------------------------\n# sets\n\n# {}\n# se não tiver : é um set e não um dicts\n\ns = {1,2,2,2,3,4,4,5}\ns\n# os valores duplicados são removidos\n\n# set can be changed \ns.add(5)\n\ns.remove(5)\n\n\n# ------------------------------\n# operators\n\n# comparações\n\na == b\n\n4 < 5\n\n# list\n[1,2,3] == [1,3,2]\n\n# set\n{1,2,3} == {1,3,2}\n\nl = [1,2,3]\n\n4 in l\n\n'R' in name\n\n# for dics in look to the key\n1 in {1:2,4:5}\n2 in {1:2,4:5}\n\n1 in l and 2 in l\n1 in l or 2 in l\n\n# casting to boolean\ni = 10\n\ni > 20 or i\n\n# transformar em booleano\nbool(10)\nbool(-1)\nbool(1.4)\nbool(0.0)\n\nbool([])\nbool([1])\nbool([[]])\n\nbool('')\nbool('teste')\nbool([''])\n\n# false = zero, empty\n# true = anything else\n\n# ------------------------------\n# conditions\n\nuser = 'Pietro'\n\nif user == 'Pietro':\n    print('Hello Pietro')\n\n\nuser = 'Pietro'\nif user == 'Pietro':\n    print('Hello Pietro')\nelse:\n    print('Who are you?')\n\n# elif\n# intermediário condicional do if, antes do else\n\na = 10\nif(a>10):\n    print(\"Value of a is greater than 10\")\nelse:\n    print(\"Value of a is 10\")\n\n\n# ------------------------------\n# loops\n\nfor person in ['Pietro','Ivette']:\n    print('Hello',person)\n\n# a variável irá armazenar a última ocorrência\nperson\n\nfor letter in 'Roney':\n    print(letter)\n     \n# ranger\n# números do loop\nrange(10)\nlist(range(10))\nrange(5,10)\nlist(range(5,10))\n\nfor i in range(10):\n    print(i**2)\n\n# vector[from:to]\n# é utilizado para visualizar valores, não para criar\n\n# loop pouco eficiente\nfor i in range(1000):\n    if i < 10:\n        print(i**2)\n\n# evitar que o loop se repita\nfor i in range(1000):\n    if i < 10:\n        print(i**2)\n    else: \n        break\n\n# menos eficiente, ele não imprime mas roda todos os loops\nfor i in range(1000):\n    if i >= 10:\n        continue\n    print(i**2)\n\n# while\ni = 1\nwhile i**2 < 1000:\n    print(i**2)\n    i += 1\n\n# obs.: o implemento += faz o while ser mais flexível em Python que em R\n\n# % resto, o que sobra de uma divisão\n10 % 3\n9 % 3\n\nfor i in range(10):\n    for j in range(1,i):\n        if i % j == 0:\n            print(i)\n\n\n# efeitos do range\nrange(2*10)\nlist(range(2*10))\nrange(2**3)\nlist(range(2**3))\n\n# ------------------------------\n# functions\n\n# sem qualquer argumento\ndef say_hello():\n    print('Hello')\n\nsay_hello()\n\n# com argumento\ndef say_hello(name):\n    print('Hello',name)\n\nsay_hello('Roney')\n\n# ela só roda com o argumento sendo explicitado\nsay_hello()\n\n# se usar o argumento com '' a função passa a funcionar com e sem argumento\ndef say_hello(name=''):\n    print('Hello',name)\n\nsay_hello('Roney')\nsay_hello()\n\ndef say_hello(name, language='English'):\n    name = name.capitalize()\n    if language == 'Portuguese':\n        print('Bom dia', name)\n    elif language == 'English':\n        print('Hello',name)\n    else:\n        print('Language unknown')\n\nsay_hello('roney', language='Portuguese')\nsay_hello('roney', language='English')\nsay_hello('roney', language='')\nsay_hello('roney')\n\n# the return argument stop the function\ndef add_together(a,b):\n    return a + b\n    print('hello')\n\nadd_together(3,5)\n\n# print hello does not work, because the return\n# usar return pode ser útil para retornar a primeira ocorrência\n# uma segunda forma de parar a execução, como o break \n\n\n# boas páticas, comentar no início\n\ndef say_hello(name, language='English'):\n    \"\"\"\n    This functions says hello to \"name\"\n    Arguments: \n    \"\"\"\n    name = name.capitalize()\n    if language == 'Portuguese':\n        print('Bom dia', name)\n    elif language == 'English':\n        print('Hello',name)\n    else:\n        print('Language unknown')\n\nsay_hello?\n\n# sphinx \n# forma de gerar códigos para documentação de funções e classes \n# é um software externo, não compensa para meu próprio código\n\n\n# ----------\n# duck typing\n\n# como checar o tipo de variável para ser executada corretamente em funções\n\ndef add_together(a,b):\n    return a + b\n\nadd_together(3,4.5)\n\nadd_together('Roney','Fraga')\n\n\ndef multiply_together(a,b):\n    return a * b\n\n# não vai executar, pois, não é número\nmultiply_together('Roney','Fraga')\n\n# somar \ndef add_all(s):\n    total = 0\n    for element in s:\n        total += element\n        return total\n\n# ------------------------------\n# importing modules\nimport math\n\nmath.log(3)\n\nfrom math import log\n\nlog(3)\n\n# o conceito de funções é chamado de module\n# criar uma pasta com códigos de python com a pasta __init__.py\n# todas as funções .py serão importadas\n# colocar o arquivo __init__.py na pasta para o python vai carregar os arquivos automaticamente\n\n# ------------------------------\n# openning a file\n\n# como não fazer\nwith open('data/quotes.csv') as a_file:\n    cotent = a_file.read()\n\n\n# lista no Python permite colocar várias tipos de variáveis, como texto, número, etc.\n# numpy é a forma de trabalhar só com um tipo de dado, permitindo vetorização\n# array é nome desse tipo de vetor\n# numpy é muito eficiente quanto a tempo de processamento\n# numpy é ótimo para trabalhar apenas com dados numéricos\n\nimport numpy as np\n\na = np.array([3,15,2,4])\na\na * 4\na.mean()\na.max()\n\n# posso colocar diferentes redes como dimensões de uma lista no python ou como um array\n# a lista é mais direto e simples, pois, ela aceita qualquer tipo de dado\n\n# pandas é otimizado para dados\n# \nimport pandas as pd\n\npop = pd.Series([1,3,5], index=['Italy','Spain','Brazil'])\n\n# o número das linhas são nomes\npop.loc['Italy']\n\n\n# pandas data frame\ngdp = pd.Series([10,333,544], index=['Italy','Spain','Brazil'])\n\n# criando um data frame a partir de um dicionário (dics) \n# nesse caso a ordem dos valores e das key  não importa, pandas faz um merge\ndf = pd.DataFrame({'population': pop, 'GDP pc': gdp})\n\ndf.loc[:,'population']\n\ndf['population']\n\ndf['GDP'] = df['population'] * df['GDP pc']\n\ndf\n\ndf.mean()\ndf.std()\n\nprices = {'car':1000,\n        'bread':0.2,\n        'house':10000}\n\ndata = pd.DataFrame({2010: prices})\n\ndata[2011] = data[2010] * 1.03\ndata['2011 ou mais'] = data[2010] * 1.03\n\ndata\n\n# nomes de colunas e indexes podem ter '' ou não, ser numéricos ou textuais\n# para saber qual o padrão fazer:\ndata.columns\ndata.index\n\n# lendo dados de arquivos externos\ndata = pd.read_csv('quotes.csv')\n\n# determinar para uma coluna ser index\ndata.set_index('time')\n\n# é possível fazer index de mais de uma coluna\ndata.set_index(['time','ticker'])\n\nimport pandas as pd\nimport pandas_datareader.data as web\nimport matplotlib\n\n# lendo dados de exemplo\napple = web.DataReader('aapl','yahoo','2018-07-01','2019-06-30')\ngoogle = web.DataReader('googl','yahoo','2018-07-01','2019-06-30')\n\ndata = pd.concat({'apple' : apple, 'google' : google})\n\n# gerando gráficos\ndata.loc['apple'][['High','Low']].plot()\ndata[['High','Low']].plot()\n\n# salvar o gráfico \nimport matplotlib.pyplot\nmatplotlib.pyplot.savefig('test_graph.pdf')\n\n```\n\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"python-introducao.html"},"language":{},"metadata":{"lang":"pt","fig-responsive":true,"quarto-version":"1.2.237","bibliography":["references.bib"],"csl":"abnt-ipea.csl","theme":{"light":"flatly","dark":"darkly"},"toc-location":"right","author-meta":"Roney Fraga Souza"},"extensions":{"book":{"multiFile":true}}}}}