{"title":"DEA","markdown":{"headingText":"DEA","containsRefs":false,"markdown":"\n\n\n- Análise Envoltória de Dados\n- Data Envelopment Analysis\n\n\n```{r filename='dea-benchmarking.R'}\n#| eval: false\n#| echo: true\n#| code-fold: show\n\n\n# TODO: Dados da Tabla 2.1 Valores observados concesionarios, do livro de Coll e Blasco (2006) \n# INPUTS\n# x1 = Número de empleados \n# x2 = Depreciación del Inmovilizado, como proxy del capital\n# OUTPUTS\n# y1 = Número de vehículos vendidos \n# y2 = Número de órdenes de trabajo recibidas en taller\n# \n# Coll e Blasco (2006) Evaluación de la Eficiencia mediante el Análisis Envolvente de Datos\n# Ferreira e Gomes (2009) Introdução à Análise Envoltória de Dados. Teoria, Modelos e Aplicações\n# Bogetoft, Otto (2011) Benchmark and frontier analysis using DEA and SFA and R\n# Author: roney\n###############################################################################\n\nlibrary(Benchmarking)\n\n## dea(X, Y, RTS = \"vrs\", ORIENTATION = \"in\", XREF = NULL, YREF = NULL,\n#\tFRONT.IDX = NULL, SLACK = FALSE, DUAL = FALSE, DIRECT = NULL, param = NULL,\n#\tTRANSPOSE = FALSE, FAST = FALSE, LP = FALSE, CONTROL = NULL, LPK = NULL)\n#\n# Tabla 2.1 Valores observados concesionarios\n#   \tx1\tx2\ty1\ty2\n#\tA\t8\t8\t14\t20\n#\tB\t11\t15\t25\t42\n#\tC\t14\t12\t8\t30\n#\tD\t12\t13\t25\t8\n#\tE\t11\t18\t40\t22\n#\tF\t18\t20\t24\t30\n\ndata.frame(x1 = c(8, 11, 14, 12, 11, 18),\n           x2 = c(8, 15, 12, 13, 18, 20),\n           y1 = c(14, 25, 8, 25, 40, 24),\n           y2 = c(20, 42, 30, 8, 22, 30)) ->\n    coll.blasco\n\nnamesAF <- c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\")\nnamesX <- c(\"x1\", \"x2\")\nnamesY <- c(\"y1\", \"y2\")\nnamesXY <- c(\"x1\", \"x2\", \"y1\", \"y2\")\n\ninsumos <- matrix(c(coll.blasco$x1, coll.blasco$x2), nrow = 6, ncol = 2, byrow = FALSE, dimnames = list(namesAF, namesX))\nis.matrix(insumos)\ninsumos\nprodutos <- matrix(c(coll.blasco$y1, coll.blasco$y2), nrow = 6, ncol = 2, byrow = FALSE, dimnames = list(namesAF, namesY))\nis.matrix(produtos)\nprodutos\n\n\n######## CCR Input Orientado #######\n# Em benchmarking modelo CCR (crs) input orientado, o problema primal é a minimização do insumos dada a\n# quantidade de produtos. Modelo envoltório (que usa lambda), ver notação página 72 Ferreira e Gomes (2009)\n\nccr.in <- dea(insumos, produtos, RTS = \"crs\", ORIENTATION = \"in\", SLACK = TRUE) # eff CCR insumo orientado com folgas\n\nsummary(ccr.in) # função que trás o resumo das medidas, como número e % de unidades eficientes em cada\n# faixa de valor, assim como folgas. Muito útil para grande quantidade de DMU's\n\nlambda(ccr.in)\t# equivalente a saída Benchmarking do SAID, indica quais DMU's estão sendo referência,\n# as que estão nas colunas, para as demais DMU's, que estão nas linhas.\n# em outras palavras, parceiros relevantes (peers) para as DMU's ineficientes, e o valor do \n# lambda indica o quanto a DMU eficiente, o benchmarking, é importante para a DMU ineficiente\n\nlambda(ccr.in, KEEPREF = TRUE)  # quando a opção \"KEEPREF = TRUE\" é utilizada todas as DMU's são mostradas\n# nas colunas, não penas as eficiêntes.\n\nprint(ccr.in$eff, digits = 2)\t# para mostrar a eficiência das DMU's\n\nwhich( ccr.in$eff == 1 & !ccr.in$slack)\t# para mostrar apenas as DMU's eficientes e sem folga\n\ndata.frame(\"eff\" = ccr.in$eff, \"ins\" = insumos, \"rad\" = ccr.in$eff * insumos, \"fol\" = ccr.in$sx, \"alv\" = insumos - ccr.in$sx) \n# i) eff, ii) insumos observados ou atual, iii) movimento radial, iv) folga e v) alvo\n# \n# iii) movimento radial é o cálculo da redução dos insumos em direção a fronteira eficiente\n# \t   e é obtido pela multiplicação dos insumos observados pela eficiência das respectivas\n#\t   unidades, ou pela multiplicação da unidade do insumo da unidade ineficiente pelo\n#\t   lambda do(s) seu(s) benchmarks. (ver página 101 de Ferreira e Gomes, 2009)\n# iv) mesmo projetando DMU em direção a fronteira eficiente devido a possibilidade\n#\t  de existir alguns seguimentos da fronteira poliangular linear paralelos aos eixos\t\n#\t  coordenadas é possível ocorrer folgas nesses pontos. Ou seja, mesmo que o movimento\n#\t  radial tenha projetado a DMU para a fronteira eficiente é possivel existir alguma\n#\t  ineficiencia, que caracterizamos como folga. (ver página 102 de Ferreira e Gomes, 2009)\n# v) o alvo é o movimento radial dimunuido das possíveis folgas\n\ndata.frame(\"eff\" = ccr.in$eff, \"pro\" = produtos, \"rad\" = ccr.in$eff * produtos, \"fol\" = ccr.in$sy, \"alv\" = produtos + ccr.in$sy)\t\n# i) eff, ii) produtos observados ou atual, iii) movimento radial, iv) folga e v) alvo\n# o mesmo do exemplo anterior mas agora aplicado para aos produtos\n\n## Problema da Dualidade ## \n# no problema dual do modelo CCR (crs) insumos orientado [maximização] é expressa a forma multiplicada desse modelo, \n# onde os lambdas são substituidos pelos peso insumo (u) e peso produto (v). ver notação pág 72 Ferreira e Gomes (2009)\n# \n# os pesos, peso insumo (u) e peso produto (v), que permitem calcular os insumos e produtos virtuais conforme são \n# obtidos na saída do SAID e no modelo insumo orientado multiplicadores (primal) de Coll e Blasco (2006) só são \n# encontrados pelo problema dual no pacote Benchmarking\nccr.in.dual <- dea.dual(insumos, produtos, RTS = \"crs\", ORIENTATION = \"in\")\nnames(ccr.in.dual)\nprint(cbind(\"eff\" = ccr.in.dual$eff, ccr.in.dual$u, ccr.in.dual$v), digits = 5) \n# o valor eficiência é exatamente igual aos do SAID e do Excel, mas os pesos apresentam valores diferentes\n  \n# para detalhes ver tabela 4.8 na página 130 de Ferreira e Gomes (2009) ou nas páginas 117 e 118 tabelas 4.2 e 4.3  \n\n\n######## CCR Output Orientado #######\n# Em benchmarking modelo CCR (crs) output orientado, o problema primal é a maximização do produto dada a\n# quantidade de insumos. Modelo envoltório (que usa lambda), ver notação página 130 Ferreira e Gomes (2009)\n\nccr.out <- dea(insumos, produtos, RTS = \"crs\", ORIENTATION = \"out\", SLACK = TRUE)\nsummary(ccr.out)\nlambda(ccr.out) # apresentou uma pequena mudança no valor dos lambdas comparado com o resultado do SAID, mas como \n# o modelo é CCR acredito não deveria acontecer isso\nlambda(ccr.out, KEEPREF = TRUE)\nprint(1 / ccr.out$eff, digits = 2)\nwhich(1 / ccr.out$eff == 1 & !ccr.out$slack)\ndata.frame(\"eff\" = 1 / ccr.out$eff, \"ins\" = insumos, \"rad\" = (1 / ccr.out$eff) * insumos, \"fol\" = ccr.out$sx, \"alv\" = insumos - ccr.in$sx)\ndata.frame(\"eff\" = 1 / ccr.out$eff, \"pro\" = produtos, \"rad\" = 1 / ccr.out$eff * produtos, \"fol\" = ccr.out$sy, \"alv\" = produtos + ccr.out$sy)\t\n# apresentou pequenas mudanças diante dos resultodos do SAID #\n\n# o problema dual do modelo CCR (crs) output orientado é a minimização, modelo dos multiplicadores, que considera\n# os pesos insumos (u) e produtos (v)\nccr.out.dual <- dea.dual(insumos, produtos, RTS = \"crs\", ORIENTATION = \"out\") # problema dual output orientado\nnames(ccr.out.dual)\nprint(cbind(\"eff\" = ccr.out.dual$eff, ccr.out.dual$u, ccr.out.dual$v), digits = 5)\n\n\n######## BCC Input Orientado #######\n# Em benchmarking modelo BCC (vrs) input orientado, o problema primal é a minimização do insumos dada a\n# quantidade de produtos. Modelo envoltório (que usa lambda), ver notação página 130 Ferreira e Gomes (2009)\n\nbcc.in <- dea(insumos, produtos, RTS = \"vrs\", ORIENTATION = \"in\", SLACK = TRUE) # eff BCC insumo orientado com folgas\nsummary(bcc.in)\nlambda(bcc.in)\nlambda(bcc.in, KEEPREF = TRUE)\nprint(bcc.in$eff, digits = 2)\nwhich(bcc.in$eff == 1 & !bcc.in$slack)\ndata.frame(\"eff\" = bcc.in$eff, \"ins\" = insumos, \"rad\" = bcc.in$eff * insumos, \"fol\" = bcc.in$sx, \"alv\" = insumos - bcc.in$sx)\ndata.frame(\"eff\" = bcc.in$eff, \"ins\" = produtos, \"rad\" = bcc.in$eff * produtos,\"fol\" = bcc.in$sy, \"alv\" = produtos + bcc.in$sy)\n\n## RENDIMENTOS DE ESCALA ## \n# na saida do SAID, além dos pesos do CCR, tem v0 que corresponde ao k da abordagem de Coll e Blasco (2006)  \nbcc.in.irs <- dea(insumos, produtos, RTS = \"irs\", ORIENTATION = \"in\", SLACK = TRUE) # eff BCC ins orientado rend crescentes\nbcc.in.drs <- dea(insumos, produtos, RTS = \"drs\", ORIENTATION = \"in\", SLACK = TRUE) # eff BCC ins orientado rend decrescentes\n\n# Ferreira e Gomes (2009) página 198\n# CCR = BCC rendimentos constantes de escala\n# DRS = RVE rendimentos decrescentes, se DRS != RVE rendimentos crescentes\n# IRS = RVE rendimentos crescentes, se IRS != RVE rendimentos decrescentes \ndata.frame(\"CRS\" = ccr.in$eff,\"VRS\"= bcc.in$eff, \"IRS\" = bcc.in.irs$eff, \"DRS\" = bcc.in.drs$eff, \"E_ESC\" = ccr.in$eff / bcc.in$eff,\n\t\t   \"REND\" = ifelse(ccr.in$eff == bcc.in$eff | bcc.in$eff == bcc.in.irs$eff & bcc.in$eff == bcc.in.drs$eff, \n\t\t\t\t\t\t \"constante\", ifelse(bcc.in$eff == bcc.in.drs$eff & bcc.in$eff != bcc.in.irs$eff, \"decrescen\", \n\t\t\t\t\t\t\t\t\t\t\t \"crescente\")))\n# de modo equivalente pode - se fazer\ndata.frame(\"CRS\"= ccr.in$eff,\"VRS\"= bcc.in$eff, \"IRS\"= bcc.in.irs$eff, \"DRS\"= bcc.in.drs$eff, \"E_ESC\"= ccr.in$eff/bcc.in$eff,\n\t\t   \"REND\"= ifelse(ccr.in$eff == bcc.in$eff | bcc.in$eff == bcc.in.irs$eff & bcc.in$eff == bcc.in.drs$eff, \n\t\t\t\t\t\t \"constante\", ifelse(bcc.in$eff == bcc.in.irs$eff & bcc.in$eff != bcc.in.drs$eff, \"crescente\", \n\t\t\t\t\t\t\t\t\t\t\t \"decrescen\")))\n\n# no problema dual do modelo BCC (vrs) insumos orientado [maximização] é expressa na forma multiplicada, onde os \n# lambdas são substituidos pelos peso insumo (u) e peso produto (v). ver notação pág 117 Ferreira e Gomes (2009)\nbcc.in.dual <- dea.dual(insumos, produtos, RTS = \"vrs\", ORIENTATION = \"in\")\nnames(bcc.in.dual)\nprint(cbind(\"eff\"= bcc.in.dual$eff, bcc.in.dual$u, bcc.in.dual$v), digits = 3)\n\n\n######## BCC Output Orientado #######\n# Em benchmarking modelo BCC (vrs) output orientado, o problema primal é a maximização do produto dada a\n# quantidade de insumos. Modelo envoltório (que usa lambda), ver notação página 118 Ferreira e Gomes (2009)\nbcc.out <- dea(insumos, produtos, RTS = \"vrs\", ORIENTATION = \"out\", SLACK = TRUE)\nsummary(bcc.out)\nlambda(bcc.out)\nlambda(bcc.out, KEEPREF = TRUE)\nprint(1/bcc.out$eff, digits = 2)\nwhich(1/bcc.out$eff == 1 & !bcc.out$slack)\ndata.frame(\"eff\"= 1/bcc.out$eff, \"ins\"= insumos, \"rad\"=(1/bcc.out$eff) * insumos,\"fol\"= bcc.out$sx, \"alv\"= insumos - bcc.in$sx)\ndata.frame(\"eff\"= 1/bcc.out$eff, \"pro\"= produtos, \"rad\"= 1/bcc.out$eff * produtos,\"fol\"= bcc.out$sy, \"alv\"= produtos + bcc.out$sy)\n\nbcc.out.irs <- dea(insumos, produtos, RTS = \"irs\", ORIENTATION = \"out\", SLACK = TRUE) # eff BCC out orientado rend crescentes\nbcc.out.drs <- dea(insumos, produtos, RTS = \"drs\", ORIENTATION = \"out\", SLACK = TRUE) # eff BCC out orientado rend decrescentes\n\ndata.frame(\"CRS\"= ccr.out$eff,\"VRS\"= bcc.out$eff, \"IRS\"= bcc.out.irs$eff, \"DRS\"= bcc.out.drs$eff,\n\t\t   \"E_ESC\"= ccr.out$eff/bcc.out$eff, \n\t\t   \"REND\"= ifelse(ccr.out$eff == bcc.out$eff | bcc.out$eff == bcc.out.irs$eff & bcc.out$eff == bcc.out.drs$eff, \n\t\t\t\t\t\t \"constante\", ifelse(bcc.out$eff == bcc.out.irs$eff & bcc.out$eff != bcc.out.drs$eff,\"crescente\",\"decrescen\")))\n# de modo equivalente pode - se escrever\ndata.frame(\"CRS\"= ccr.out$eff,\"VRS\"= bcc.out$eff, \"IRS\"= bcc.out.irs$eff, \"DRS\"= bcc.out.drs$eff,\n\t\t   \"E_ESC\"= ccr.out$eff/bcc.out$eff, \n\t\t   \"REND\"= ifelse(ccr.out$eff == bcc.out$eff | bcc.out$eff == bcc.out.irs$eff & bcc.out$eff == bcc.out.drs$eff, \n\t\t\t\t\t\t \"constante\", ifelse(bcc.out$eff == bcc.out.drs$eff,\"decrescen\",\"crescente\")))\n\n### CUIDADO!! quando exite diferença entre as variáves selecionadas, considerando muitas casa \n### decimais, pode ocorrer equívocuo na análise de rendimentos de escala. para evitar esse erro é necessário \n### limitar o número de casa decinais com a função round(x, digits = n)\nprint(cbind(\"CRS\"= ccr.out$eff, \"VRS\"= bcc.out$eff, \"IRS\"= bcc.out.irs$eff,\"DRS\"= bcc.out.drs$eff), digits = 18)\nee <- data.frame(round((cbind(\"CRS\"= ccr.out$eff, \"VRS\"= bcc.out$eff, \"IRS\"= bcc.out.irs$eff,\"DRS\"= bcc.out.drs$eff)), \n\t\t\t\t\t   digits = 6))\ndata.frame(ee, \"E_ESC\"= ee$CRS/ee$VRS,\"REND\"= ifelse(ee$CRS == ee$VRS | ee$VRS == ee$IRS & ee$VRS == ee$DRS, \n\t\t\t\t\t\t\t\t\t\t\t\t   \"constante\", ifelse(ee$VRS == ee$IRS & ee$VRS != ee$DRS,\"crescente\",\"decrescen\")))\n\n# o problema dual BCC (vrs) output orientado é de minimização, na forma multiplicada que considera os pesos dos \n# insumos (u) e produtos (v)\nbcc.out.dual <- dea.dual(insumos, produtos, RTS = \"vrs\", ORIENTATION = \"out\") # problema dual\nnames(bcc.out.dual)\nprint(cbind(\"eff\"= bcc.out.dual$eff, bcc.out.dual$u, bcc.out.dual$v), digits = 5)\n\n\n######## Análise de Supereficiência #######\n# ver Coll e Blasco (2006) capítulo 4 página 135\n# ver Ferreira e Gomes (2009) capítulo 4 página 136\ns.ccr.in <- sdea(insumos, produtos, RTS = \"crs\", ORIENTATION = \"in\")\ndata.frame(\"CRS\"= ccr.in$eff, \"CCR_SUPER\"= s.ccr.in$eff)\n\ns.ccr.out <- sdea(insumos, produtos, RTS = \"crs\", ORIENTATION = \"out\")\ndata.frame(\"CCR\"= 1/ccr.out$eff, \"CCR_SUPER\"= 1/s.ccr.out$eff)\n\n######## Modelo FHD #######\n# ver Ferreira e Gomes (2009) capítulo 4 página 143\nbcc.in.fhd <- dea(insumos, produtos, RTS = \"fdh\", ORIENTATION = \"in\")\ndata.frame(\"CRS\"= ccr.in$eff,\"VRS\"= bcc.in$eff, \"IRS\"= bcc.in.irs$eff, \"DRS\"= bcc.in.drs$eff, \"FHD\"= bcc.in.fhd$eff)\n\nbcc.out.fhd <- dea(insumos, produtos, RTS = \"fdh\", ORIENTATION = \"out\")\ndata.frame(\"CRS\"= 1/ccr.out$eff,\"VRS\"= 1/bcc.out$eff, \"IRS\"= 1/bcc.out.irs$eff, \"DRS\"= 1/bcc.out.drs$eff, \n\t\t   \"FHD\"= 1/bcc.out.fhd$eff)\n\n######## Seleção de variáveis ########\ncor(coll.blasco, use = \"all.obs\", method = c(\"spearman\")) # teste de correlação de Spearman\ncor(coll.blasco, use = \"all.obs\", method = c(\"kendall\")) # teste de correlação de Kendall\ncor(coll.blasco, use = \"all.obs\", method = c(\"pearson\")) # teste de correlação de Pearson\n\n\n######## Eficiência custo (econômica), alocativa, receita e lucro #######\n# ver Ferreira e Gomes (2009) capítulo 5 página 213\nins <- data.frame(insumos)\np.ins <- data.frame(\"px1\"= c(2,2,2,2,2,2), \"px2\"= c(6,4,3,4,3,2))\neff.cost <- cost.opt(ins, produtos, p.ins, RTS = \"vrs\")\nprint(cbind(ins, p.ins,\n\"custo_min\"= eff.cost$cost, \n\"eff_econ\"= eff.cost$cost/ (ins$x1 * p.ins$px1 + ins$x2 * p.ins$px2), \n\"eff_tec\"= bcc.in$eff, \n\"eff_aloc\"=(eff.cost$cost/ (ins$x1 * p.ins$px1 + ins$x2 * p.ins$px2))/bcc.in$eff), digits = 3)\n\npro <- data.frame(produtos)\np.pro <- matrix(1, nrow = dim(pro)[1], ncol = 2)\neff.renevue <- revenue.opt(ins, pro, p.pro, RTS = \"vrs\")\neff.profit <- profit.opt(ins, pro, p.ins, p.ins, RTS = \"vrs\")\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"projeto-dea.html"},"language":{},"metadata":{"lang":"pt","fig-responsive":true,"quarto-version":"1.2.237","bibliography":["references.bib"],"csl":"abnt-ipea.csl","theme":{"light":"flatly","dark":"darkly"},"toc-location":"right","author-meta":"Roney Fraga Souza"},"extensions":{"book":{"multiFile":true}}}}}