{"title":"Primeiros passos","markdown":{"headingText":"Primeiros passos","containsRefs":false,"markdown":"\n\n**neovim atalhos**\n\n- `\\s` to start the interpreter.\n- `<Space>` to send the current line to the interpreter.\n- `\\<Space>` to send the current line to the interpreter and keep the cursor on the current line.\n- `\\q` to send the quit command to the interpreter.\n- `<Space>` to send a selection of text to the interpreter.\n- `\\p` to send from the line to the end of paragraph.\n- `\\b` to send block of code between the two closest marks.\n- `\\f` to send the entire file to the interpreter.\n- `\\m` to send the text in the following motion to the interpreter. For example \n- `\\miw` would send the selected word.\n\n**chamar Julia dentro do R:** `JuliaCall::julia_console`\n\n`Rworkspace/julia`\n\n## Básico\n\n```{julia}\n#| eval: false \n#| echo: true\n#| code-fold: true\n\n# ----------\n# básico\n\n1 + 1\n2 + 2\n2 * 2\n4 / 2\n\n\"Hello World\"\nprint(\"Hello World\")\n\n# adiciona nova linha na tela\nprintln(\"Hello World\")\n\n# ; ponto e vírgula no final do comando não mostra o resultado\n2 * 2;\n\n# resetar o ambiente de trabalho\nworkspace()\n\n\n# ----------\n# pacotes\n\n# habilitar instalador de pacotes\nusing Pkg\n\n# instalar pacotes DataFrames\nPkg.add(\"DataFrames\")\n\n# habilitar  DataFrames\nusing DataFrames\n\n# sintax Pkg.[comando]\n# exemplo\nDataFrames.groupby\n\n\n# ----------\n# help\n\n# help com ?[comando]\n?sort\n?DataFrames\n?DataFrames.describe\n\n# ] para entrar no help do pacote Pkg\n]\n\n# help retorna todas as funções\nhelp    \n\n# ?[função] retorna o help da função de determinado pacote\n?rm     \n\n# backspace retorna para o help geral do julia\n`backspace`\n\n\n# ----------\n# unicode\n\n# \\alpha \\beta \\pi \n\nα = 2\nβ = 3\n\nα * β\n\nπ\n\n\n# ----------\n# variáveis\n\nnova_var = \"Hello World\"\n\n# podem ser atualizadas\nnova_var = \"Hello World - version updated \"\n\nnova_var2 = \"Algum texto\"\n\nnova_var * nova_var2\n\n# tipo de variável\ntypeof(nova_var)\ntypeof(α)\n\n\n# ----------\n# operadores aritiméticos\n\n# ordem: / * + -\n2 + 5 - 6 / 2 * 3\n\n(2 + 5) - (6 / 2) * 3\n\n6 / 2 * 3\n\n\n# ----------\n# comentários\n\n# para uma única linha, ou \n\n \"\"\" para \n várias \n linhas, \n até terminar com\n \"\"\"\n\n#= \nou mesmo\numa \nforma \nmais \nsimples\n=#\n\n\n# ----------\n# forma correta de nomear variáveis\n\n# variáveis devem começar com letras\na = \"essa é uma variável\"\n\na1 = \"também um um bom nome\"\n\n# var_name@ não é permitido\n\n# quote, e outros nomes reservados não são permitidos\n\n\n# ----------\n# Arrays \n\n# arrays são escritos com: [,]\na1 = [1, 2, 3, 4, 5]\n\n# float\na2 = [1, 2.0, 3, 4, 5]\n\ns1 = [\"I\", \"Love\", \"Julia\"]\n\ns1[1]\ns1[2]\ns1[3]\n\n# merge\n[a1, a2]\n\n# array de funções\nf1 = [print, println, printstyled]\n\n# mistura tipos\na3 = [1, 2.0, \"Julia\"]\n\n# determinar o tipo\ntype_int = Int64[1, 2, 3, 4, 5]\ntype_string = String[\"I\", \"Love\", \"Julia\"]\n\n# duas dimensões\narray_2d = [1 2 3 4; 5 6 7 8]\n\n# selecinar sub-arrays\narray_2d[:,2]\narray_2d[1,:]\n\narray_rand = rand(3)\narray_rand_2d = rand(3, 3)\n\n\n# ----------\n# ranges\n\n1:10\ncollect(1:10)\n\n# início, intervalor, fim\ncollect(1.5:.5:5.5)\ncollect(1:10:100)\ncollect(0:10:100)\ncollect(100:-20:0)\n\n# selecionando o segundo elemento\ncollect(100:-20:0)[2]\n\ncollect(100:-20:0)[end-1]\ncollect(100:-20:0)[begin:3]\ncollect(100:-20:0)[1:3]\n\n\n# ----------\n# tuples\n\n# () parêntesis\nt1 = (1, 2, 3, 4, 5)\n\n# arrays in [] \na1 = [1, 2, 3, 4, 5]\n\n# imutáveis, diferente de arrays\na1[2] = 20\na1\n\n# erro\nt1[2] = 20\n\n# duas dimensões\nt2 = ((1, 2), (3, 4))\n\n# acessar tuples de duas dimensões\nt2[1][2]\n\n# merge\nt3 = (aa = (1, 2), bb = (3, 4))\nt4 = (cc = (5, 6))\n\n(t3, t4)\n\n\n# ----------\n# dictionary\n\n# pares de chaves e valores: eficientes\n\n# key são strings\n# values são intinger\nCars = Dict(\"Car1\" => 1000, \"Car2\" => 2000, \"Car3\" => 3000)\n\nCars[\"Car1\"]\n\n# forma alternativa \nCars2 = Dict(:Car1 => 1000, :Car2 => 2000, :Car3 => 3000)\n\nCars2[:Car1]\n\n# determinado dicionário tem uma chave?\nhaskey(Cars2, :Car3)\nhaskey(Cars2, :Car4)\n\ndelete!(Cars2, :Car1)\nkeys(Cars2)\nvalues(Cars2)\nmerge(Cars, Cars2)\n\n\n# ----------\n# sets\n\n# não aceita elementos duplicados, e não importa a ordem\n\nsports_brands = Set([\"Adidas\", \"Nike\" , \"Puma\", \"Rebook\"]) \n\nin(\"HRX\", sports_brands)\nin(\"Puma\", sports_brands)\n\nsports_brands_new = Set([\"Adidas\", \"Nike\" , \"HRX\", \"Rebook\"]) \n\nunion(sports_brands, sports_brands_new)\nintersect(sports_brands, sports_brands_new)\nsetdiff(sports_brands, sports_brands_new)\n\npush!(sports_brands, \"marca_adicionada\")\n\n\n# ----------\n# date and time\n\nusing Dates\n\nnow()\ntoday()\n\ndata = Date(2000, 2, 5) # YYYY-MM-DD\ndata_hora = DateTime(2000, 2, 5, 10, 15, 25) # YYYY-MM-DD-HH:MM:SS\n\n# extrair parte da data\nyear(data_hora)\nmonth(data_hora)\nday(data_hora)\nhour(data_hora)\nminute(data_hora)\nsecond(data_hora)\ndayofyear(data_hora)\ndayname(data_hora)\n\nDates.format(data, \"yy-mm-dd\")\n\n# ou \nformato = Dates.format(\"yy-mm-dd\") \nDates.format(data, \"yy-mm-dd\")\n\n# time zone\nnow(UTC)\n\n\n# ----------\n# conditionals\n\na = 10\n\n# if ?\na > 10 ? \"Yes\" : \"No\"\n\na >= 10 ? \"Yes\" : \"No\"\n\nb = 20\n\n# or ||\na >= 10 || b < 20\n\n# and &&    \na >= 10 && b < 20\na >= 10 && b <= 20\n\nif a > 10\n    print(\"a é maior que 10\")\nelseif a < 10\n    print(\"a é menor que 10\")\nelse\n    print(\"a é igual a 10\")\nend\n\ncountry = \"Brazil\"\n\nif country == \"Brazil\" \n    print(\"mencionou Brazil\")\nelse\n    print(\"falou errado\")\nend\n\n\n# ----------\n# loops\n\nfor i in sports_brands\n    print(i, \" \")\nend\n\nfor i in sports_brands\n    println(i)\nend\n\nfor i in [\"Adidas\", \"Puma\", \"Nike\"]\n    println(i)\nend\n\nfor i in \"Adidas\"\n    println(i)\nend\n\nfor i in (1:9)\n    println(i)\nend\n\nfor range in (1:9)\n    @show range\nend\n\nfor i in 1:10\n    j = i * 10\n    println(\"$(j) é multiplicação entre $(i) e 10\")\nend\n\n# encontrar números primos\nfor i in 1:10\n    if i % 2 == 0\n        continue\n    end\n    println(i)\nend\n\na = 1\n\nwhile a < 10\n    println(a)\n    a += 1\nend\n\n\n# ----------\n# comprehensions\n\n# loops escritos de forma mais eficiente\nx = [i for i in 1:10]\n\nx = [i * 2 for i in 1:10]\n\nx = [i^2 for i in 1:10]\n\n# salvar como Set\ns = Set([i for i in 1:10])\n\n# gerando dicionário com chaves para números\nalphabet = Dict(string(Char(x1 + 64)) => x1 for x1 in 1:26)\n\n# tupple array generated with comprehensions\n[(x, y) for x in 1:3, y in 1:2]\n\n[x for x in 1:10 if x%2 ==0]\n\n\n# ----------\n# working with strings\n\ns1 = \"I love Julia\"\n\nlength(s1)\nlastindex(s1)\n\ns1[4]\ns1[3:6]\n\n# combinar strings\n\"Love\" * \"Julia\"\n\n\"Love\" ^ 5\n\nstring(\"Love \", \"Julia\")\n\n# dividir string\nsplit(s1)\nsplit(s1, \"e\")\nsplit(s1, \"\")\n\nparse(Int64, \"100\")\nparse(Float64, \"100.5\")\n\n# encontrar\n# aspas simples\nin('I', s1)\n\noccursin(\"love\", s1)\n\nfindfirst(\"l\", s1)\nfindfirst(\"love\", s1)\ns1 = replace(s1, \"love\" => \"adore\")\n\n\n# ----------\n# functions\n\n# forma compacta\nf(x) = x * x\nf(10)\n\n# forma compacta\nf(x, y) = x * 2 - y\nf(10, 12)\n\n# forma padrão\nfunction multiply(x, y)\n    return x * y\nend\n\nmultiply(2, 4)\n\nfunction convert_meter_to_inch(val)\n    return val * 39.37\nend\n\nconvert_meter_to_inch(1.5)\n\nfunction convert_meter_to_inch(val, name = \"Patron\")\n    if name == \"Patron\"\n        println(\"Value for name is not supplied\")\n    else \n        println(\"Hi..\", name, \" The conversion value is \")\n    end\n        return val * 39.37\nend\n\nconvert_meter_to_inch(2.3)\nconvert_meter_to_inch(2.3, \"Teteti\")\n\n\n# ----------\n# formatting numbers and strings\n\nusing Printf\n\nname = \"Teteti\"\n\n# não imprimir\nname = \"Teteti\";\n\n@printf(\"Hello %s\", name)\n@sprintf(\"Hello %s\", name)\n\nch = 'i'\n@printf(\"%c\", ch)\n\nx = 100\n@printf(\"Value of x is %d\", x)\n\ny = 100.5\n@printf(\"Value of x is %f\", y)\n\n# contrar número de casas decimais\n@printf(\"Value of x is %.2f\", y)\n\n# transformar em notação científica\nz = 1243987234\n@printf(\"%e\", z)\n@printf(\"%.2e\", z)\n\n\n# ----------\n# working with real word files .csv\n\nusing Pkg\n\n# instalar\nPkg.add(\"CSV\")\n\nusing CSV\nusing DataFrames\n\nmtcars = CSV.read(\"mtcars.csv\", DataFrame)\ntypeof(mtcars)\n\nnames(mtcars)\nsize(mtcars)\n\n\n# ----------\n# DataFrames\n\nmtcars.gear\nmtcars.mpg\nmtcars[:, \"mpg\"]\nmtcars[:, 2:5]\nmtcars[:, [2, 4, 6]]\nmtcars[1:6, [1, 2, 4, 6]]\n\nDataFrame(x = [1, 2, 3], y = 4:6, z = 9)\nDataFrame([(x = 1, y = 2), (x = 3, y = 4)])\nDataFrame(\"x\" => [1, 2], \"y\" => [3, 4])\nDataFrame(x = Int[], y = Float64[])\n\n# o \".\" ponto, indicar aplicar para todas as linhas\nmtcars[mtcars.mpg .>= 30, :]\n\n# reshape pivot_[longer or wider]\nstack()\nunstack()\n\nsort(mtcars, :mpg)\nnrow(mtcars)\nncol(mtcars)\nnames(mtcars)\n\n# NA\ndropmissing()\nalowmissing()\ndisasalowmissing()\ncompletecases()\n\n# summarize data\ncombine(mtcars, :mpg => sum)\ncombine(mtcars, :mpg => sum => :mpg_sum)\ntransform()\n\n# combine data sets\ninnerjoin()\nleftjoin()\nrightjoin()\nouterjoin()\nsemijoin()\nantijoin()\nvcat()\nhcat()\n\n\n# ----------\n# estatísticas descritivas\n\ndescribe(mtcars)\ndescribe(mtcars, :mean, :std)\n\n\n# ----------\n# files ystem\npwd()\nreaddir()\nmkdir()\ncd()\nmkpath()\nisdir()\n\n\n# ----------\n# pipe\n\nusing Pkg\nusing Pipe: @pipe # para evitar conflito com Base.Pipe\nusing CSV\nusing DataFrames\n\na1 = [1, 2, 3, 4, 5]\n\n@pipe a1 |> sum()\n\nsum(a1)\n\nmtcars = CSV.read(\"mtcars.csv\", DataFrame)\n\n# group data sets e pipe |>\n@pipe mtcars |>\n    filter(:cyl => == (\"6\"), _) |>\n    groupby(mtcars, :gear) |>\n    combine(_, :mpg => sum)\n\n```\n\n# Julia a partir do R\n\n\n```{julia}\n#| eval: false \n#| echo: true\n#| code-fold: true\n\n# oficial\n# https://non-contradiction.github.io/JuliaCall/index.html\n\n# install.packages(c('JuliaCall'), dependencies = TRUE) \nlibrary(JuliaCall)\n\njulia <- julia_setup()\n\n#> Julia version 1.7.2 at location /Applications/Julia-1.7.app/Contents/Resources/julia/bin will be used.\n#> Loading setup script for JuliaCall...\n#> Finish loading setup script for JuliaCall.\n\n## If you want to use `Julia` at a specific location, you could do the following:\n## julia_setup(JULIA_HOME = \"the folder that contains Julia binary\").\n## You can also set JULIA_HOME in command line environment or use `options(...)`.\n\n## Different ways of using Julia to calculate sqrt(2)\n\njulia$command(\"a = sqrt(2);\"); julia$eval(\"a\")\njulia_command(\"a = sqrt(2);\"); julia_eval(\"a\")\njulia_eval(\"sqrt(2)\")\njulia_call(\"sqrt\", 2)\njulia_eval(\"sqrt\")(2)\njulia_assign(\"x\", sqrt(2)); julia_eval(\"x\")\njulia_assign(\"rsqrt\", sqrt); julia_call(\"rsqrt\", 2)\n2 %>J% sqrt\n\n## You can use `julia$exists` as `exists` in R to test\n## whether a function or name exists in Julia or not\n\njulia_exists(\"sqrt\")\njulia_exists(\"c\")\n\n## Functions related to installing and using Julia packages\n\njulia_install_package_if_needed(\"Optim\")\njulia_installed_package(\"Optim\")\njulia_library(\"Optim\")\n\n## help\njulia_help(\"sqrt\")\n```\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"julia-introducao.html"},"language":{},"metadata":{"lang":"pt","fig-responsive":true,"quarto-version":"1.2.237","bibliography":["references.bib"],"csl":"abnt-ipea.csl","theme":{"light":"flatly","dark":"darkly"},"toc-location":"right","author-meta":"Roney Fraga Souza"},"extensions":{"book":{"multiFile":true}}}}}