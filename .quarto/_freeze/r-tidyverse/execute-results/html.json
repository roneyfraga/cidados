{
  "hash": "82a4b096ce411f302c3487072733269b",
  "result": {
    "markdown": "\n# `tidyverse` everything\n\n- Parte 1: `tibble` e `pipe` \n- Parte 2: `dplyr` basic\n- Parte 3: `tidyr` basic\n- Parte 4: `dplyr` advanced\n- Parte 5: `tidyr` advanced\n\n`code/cidados_aula03.R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ------------------------------------------------------------\n# \n# File Name: cidados_aula03.R\n#\n# Purpose: Ciência de Dados para Economistas - Faculdade de Economia UFMT\n# \n# Creation Date: 2020-11-02\n# Last Modified: 2022-09-08_13:25\n# Created By: Roney Fraga Souza\n# E-mail: roneyfraga@gmail.com\n# roneyfraga.com\n# \n# Licence:\n#\n# Creative Commons Attribution-NonCommercial-ShareAlike \n# CC BY-NC-SA\n# http://creativecommons.org/licenses/by-nc-sa/3.0/\n#\n# ------------------------------------------------------------\n\n\n# Structure\n# Part 1: tibble and pipe \n# Part 2: dplyr basic\n# Part 3: tidyr basic\n# Part 4: dplyr advanced\n# Part 5: tidyr advanced\n\n\n# ------------------------------\n## Preparing the home\n\n#install.packages(c('tibble','dplyr','magrittr','pipeR'))\nlibrary(tibble)\nlibrary(dplyr)\nlibrary(tidyr) \nlibrary(magrittr)\nlibrary(pipeR)\nlibrary(nycflights13)\n\n# or to load all tidyverse family  \n# install.packages('tidyverse')\n# library(tidyverse)\n\n\n# ------------------------------\n## tibble and pipe\n#\n# https://tibble.tidyverse.org/index.html\n\n?starwars\n# Description: Starwars characters\n# A tibble with 87 rows and 13 variables:\n# name: Name of the character\n# height: Height (cm)\n# mass: Weight (kg)\n# hair_color,skin_color,eye_color: Hair, skin, and eye colors\n# birth_year: Year born (BBY = Before Battle of Yavin)\n# gender: male, female, hermaphrodite, or none.\n# homeworld: Name of homeworld\n# species: Name of species\n# films: List of films the character appeared in\n# vehicles: List of vehicles the character has piloted\n# starships: List of starships the character has piloted\n \ndata(starwars)\nstarwars\nclass(starwars)\n\n# é possível transformar um data frame em tibble\ndata(mtcars)\nmtcars\ntibble::as_tibble(mtcars)\n\nmtcars_tbl <- as_tibble(mtcars)\nclass(mtcars_tbl)\nclass(mtcars)\nmtcars_tbl[1:3, ]\n\n# criar um tibble\ntibble(x = 1:5, y = 1, z = x ^ 2 + y)\n\ntribble(\n  ~x, ~y,  ~z,\n  \"a\", 2,  3.6,\n  \"b\", 1,  8.5\n)\n\n# trabalhando com muitos dados\nflights\ndplyr::glimpse(flights)\nprint(flights, n = 20)\n# print(flights, n = Inf)\n\nflights_df <- as.data.frame(flights)\ndim(flights_df)\nnames(flights_df)\nhead(flights_df)\nhead(flights_df, 8)\nflights_df\n\n# ------------------------------\n## magrittr pipe %>% and base-R pipe |>\n\n# traditional code\n# fácil para ler, mas demorado para escrever\nsample_mtcars <- sample(mtcars$mpg, 10000, replace = TRUE)\ndensity_mtcars <- density(sample_mtcars, kernel = \"gaussian\")\nplot(density_mtcars, col = \"red\", main = \"density of mpg (bootstrap)\")\n\n# traditional code, compact version\n# fácil para escrever e difícil para ler\nplot(density(sample(mtcars$mpg, size = 10000, replace = TRUE), kernel = \"gaussian\"), col = \"red\", main = \"density of mpg (bootstrap)\")\n\n# steps:\n# 1 Resample from mtcars$mpg\n# 2 Perform a kernel estimation of its distribution\n# 3 Plot the estimated density function\n\n# pipe (magrittr) style\nmtcars$mpg %>%\n  sample(size = 10000, replace = TRUE) %>%\n  density(kernel = \"gaussian\") %>%\n  plot(col = \"red\", main = \"density of mpg (bootstrap)\")\n\n# pipe (base-R) style\nmtcars$mpg |>\n  sample(size = 10000, replace = TRUE) |>\n  density(kernel = \"gaussian\") |>\n  plot(col = \"red\", main = \"density of mpg (bootstrap)\")\n\n# tradicional\nmean(mtcars$mpg)\n\n# pipe\nmtcars$mpg |>\n    mean()\n\nmtcars$mpg |> \n    mean() |> \n    log()\n\nlog(mean(mtcars$mpg))\n\n# forma fácil de escrever e difícil de ler\nsqrt(mean(1:30))\n\n# forma pipe\n1:30 |> mean() |> sqrt()\nc(1:30, 40) |> mean() |> sqrt()\n\n\n# ------------------------------\n# Part 2: dplyr basic\n\n# Introduction to dplyr\n# https://dplyr.tidyverse.org/articles/dplyr.html\n\n# ----------\n# dplyr             \n#\n# Single table verbs\n# dplyr aims to provide a function for each basic verb of data manipulation. These verbs can be organised into three categories based on the component of the dataset that they work with:\n# \n# Rows:\n#   filter() chooses rows based on column values.\n#   slice() chooses rows based on location.\n#   arrange() changes the order of the rows.\n#\n# Columns:\n#   select() changes whether or not a column is included.\n#   rename() changes the name of columns.\n#   mutate() changes the values of columns and creates new columns.\n#   relocate() changes the order of the columns.\n#\n# Groups of rows:\n#   summarise() collapses a group into a single row.\n\n\n# ---\n# dica 1\n# snippets no rstudio\n# copiar o arquivo snippets em:\n#\n# https://github.com/roneyfraga/vim-snippets/blob/master/snippets/r.snippets\n#\n# e colar no RStudio em \n# Glocal Option -> Code -> R\n# agora basta pressionar o atalho e Tab\n\n\n# ------------------------------\n## Preparing the home\n\n# loading packages\nlibrary(tibble)\nlibrary(dplyr)\nlibrary(nycflights13)   # apenas para carregar dados para exemplos\n\n# load example data\ndata(starwars)      # dplyr example\n\n?starwars\n# Description: Starwars characters\n# A tibble with 87 rows and 13 variables:\n# name: Name of the character\n# height: Height (cm)\n# mass: Weight (kg)\n# hair_color,skin_color,eye_color: Hair, skin, and eye colors\n# birth_year: Year born (BBY = Before Battle of Yavin)\n# gender: male, female, hermaphrodite, or none.\n# homeworld: Name of homeworld\n# species: Name of species\n# films: List of films the character appeared in\n# vehicles: List of vehicles the character has piloted\n# starships: List of starships the character has piloted\n\n# ------------------------------\n## filter: select lines\n\nglimpse(starwars)\ndplyr::glimpse(starwars)\n\nclass(starwars)\n\n# r-base\nstarwars[starwars$skin_color == \"light\" & starwars$eye_color == \"brown\", ]\n\n# filter without pipe \ndplyr::filter(starwars, skin_color == \"light\", eye_color == \"brown\")\n\n# dplyr with pipe \nstarwars |> dplyr::filter(skin_color == \"light\", eye_color == \"brown\")\n\n# better indentation\nstarwars |> \n    dplyr::filter(skin_color == \"light\", eye_color == \"brown\") \n\nstarwars |> \n    dplyr::filter(skin_color == \"light\", eye_color == \"brown\") |>\n    dplyr::select(name, height, mass, skin_color, eye_color) |>\n    dplyr::rename(peso = mass) |>\n    dplyr::mutate(altura_metros = height / 100) \n\n# forma Roney\nstarwars |> \n    dplyr::filter(skin_color == \"light\", eye_color == \"brown\") |>\n    dplyr::select(name, height, mass, skin_color, eye_color) |>\n    dplyr::rename(peso = mass) |>\n    dplyr::mutate(altura_metros = height / 100) ->\n    nova_tabela1\n\n# mesmo resultado\na = 1\na <- 1\n1 -> a\n\nnova_tabela2 <-\n        starwars |> \n    dplyr::filter(skin_color == \"light\", eye_color == \"brown\") |>\n    dplyr::select(name, height, mass, skin_color, eye_color) |>\n    dplyr::rename(peso = mass) |>\n    dplyr::mutate(altura_metros = height / 100) \n\n\n# ------------------------------\n## arrange: reorder rows\n\nstarwars |> arrange(height, mass)\n\nstarwars |> \n    arrange(height, mass) |> \n    select(name, height, mass)\n\nstarwars |> \n    arrange(desc(height), mass) |> \n    select(name, height, mass)\n\nstarwars |> \n    dplyr::arrange(dplyr::desc(height), mass) |> \n    dplyr::select(name, height, mass) ->\n    st\n\nst\nprint(st, n = 20)\nst |> print(n = 20)\nst |> print(n = Inf)\n\n\n# ------------------------------\n## slice: choose rows\n\nslice(starwars, 5:10)\n\nstarwars |> slice(5:10)\n\n# head\nstarwars |> slice_head(n = 3)\nstarwars |> slice_head(n = 10) \n\nhead(starwars, 3)\n\n# tail\nstarwars |> slice_tail(n = 3)\n\n# randomly selects rows\nstarwars |>  \n    slice_sample(n = 5) |>  \n    select(name, species, homeworld)\n\n# randomly selects 12% of the rows\nstarwars |>  \n    slice_sample(prop = 0.12) |>  \n    select(name, species, homeworld)\n\nstarwars |>  \n    slice_sample(prop = 0.05) |>  \n    select(name, species, homeworld)\n\n?slice_sample\n\n# slice_min() and slice_max() select rows with highest or lowest values of a variable. Note that we first must choose only the values which are not NA.\nstarwars |> \n    dplyr::filter(!is.na(height)) |> \n    slice_max(height, n = 3) |>  \n    select(name, species, homeworld, height)\n\n# ------------------------------\n## select: select columns\n\nstarwars |> glimpse()\nnames(starwars)\n\nstarwars |> select(hair_color, skin_color, eye_color)\n\nstarwars |> select(hair_color:eye_color)\nstarwars |> select(hair_color:gender)\n\nstarwars |> select(!(hair_color:eye_color))\n\nstarwars |> select(ends_with(\"color\"))\n\n# existem caminhos sólidos no base-R, contudo dplyr é mais conveniente\n# utilizando expressões regulares (regex)\na <- grep('color$', names(starwars))\nstarwars |> select(a)\n\nstarwars |> select(!(ends_with(\"color\")))\n\nstarwars |> select(contains(\"color\"))\n\nstarwars |> \n    select(contains(\"color\"), everything()) ->\n    st2\n\nstarwars |> \n    select(contains(\"color\"), everything()) |> \n    glimpse()\n\n# select works great with: starts_with(), ends_with(), matches(), contains(), everything()\n\n# select and rename: select() drops all the variables not explicitly mentioned\nstarwars |>     \n    select(home_world = homeworld)\n\n# rename keeps all variables \nstarwars |> \n    dplyr::rename(home_world = homeworld) |> \n    dplyr::glimpse()\n\nstarwars |> \n    dplyr::rename(personagem = name, altura = height) |> \n    dplyr::glimpse()\n\n# ------------------------------\n## mutate: add new columns\n\nmutate(starwars, height_m = height / 100)\n\nstarwars |> \n    dplyr::mutate(height = height / 100) |>\n    dplyr::select(name, height) \n\nstarwars |>\n    mutate(height_m = height / 100) |>\n    select(name, height_m, height, everything())\n\nstarwars |>\n    mutate(height_m = height / 100) |>\n    select(name, height_m, height, everything()) |> \n    glimpse()\n\n# mutate allows you to refer to columns that you’ve just created\nstarwars |>\n    mutate(\n           height_m = height / 100,\n           BMI = mass / (height_m^2)\n           ) |>\n    select(name, height_m, BMI) |>\n    slice_max(BMI, n = 10)\n\n# If you only want to keep the new variables, use transmute():\nstarwars |>\n    transmute(\n              height_m = height / 100,\n              BMI = mass / (height_m^2)\n    )\n\nstarwars |>\n    transmute(height_m = height / 100, BMI = mass / (height_m^2)) \n\n# ------------------------------\n## relocate: change column order\n\nstarwars |> glimpse()\n\nstarwars |> \n    relocate(sex:homeworld, .before = height) \n\nstarwars |> \n    relocate(sex:homeworld, .before = height) |> \n    glimpse()\n\nstarwars |> \n    relocate(sex:homeworld, .after = height) |> \n    glimpse()\n\nstarwars |> \n    relocate(ends_with('color'), .before = name) |>\n    glimpse()\n\nstarwars |> \n    relocate(contains('color'), .after = name) |>\n    glimpse()\n\nstarwars |> \n    relocate(contains('color')) ->\n    starwars\n\nstarwars |> glimpse()\n\n\n# ------------------------------\n## summarise: summarise values \n\n# It collapses a data frame to a single row.\nstarwars |> \n    summarise(height = mean(height, na.rm = TRUE))\n\n# R-base way\nmean(starwars$height, na.rm = T)\n\n# It’s not that useful until we learn the group_by() verb.\nstarwars |> \n    mutate(height_m = height / 100) |> \n    group_by(sex) |> \n    summarise(height_mean = mean(height_m, na.rm = TRUE),\n              height_max = max(height_m, na.rm = TRUE),\n              height_min = min(height_m, na.rm = TRUE),\n              n = n())\n\nstarwars |> count(sex)\n\n# mean\naggregate(starwars$height, list(sex = starwars$sex), mean, na.rm = T)\n\n# max\naggregate(starwars$height, list(sex = starwars$sex), max, na.rm = T)\n\n# applying filter before group_by\nstarwars |> \n    dplyr::filter(!is.na(height)) |> \n    dplyr::filter(!is.na(sex)) |> \n    mutate(height_m = height / 100) |> \n    group_by(sex) |> \n    summarise(height_mean = mean(height_m),\n              height_max = max(height_m),\n              height_min = min(height_m),\n              group_size = n()) |> \n    arrange(desc(height_mean))\n\n# group_by only does nothing\nstarwars |> group_by(sex)  \n\n\n\n# ------------------------------\n## Grouped data\n#\n# https://dplyr.tidyverse.org/articles/grouping.html\n\n# group_by(): it takes a data frame and one or more variables to group by:\nby_species <- starwars |> group_by(species)\n\ntable(starwars$species)\ncbind(table(starwars$species))\nstarwars |> count(species, sort = T)\n\nstarwars |> \n    group_by(species) |>\n    summarise(height_mean = mean(height, na.rm = T)) ->\n    tt\n\n#-----------\n# off-topic: import and export \n\nwrite.csv(tt, file = 'rawfiles/tt.csv')\nwrite.csv2(tt, file = 'rawfiles/tt2.csv', row.names = F)\nwrite.table(tt, file = 'rawfiles/tt3.txt', sep = '|', quote = F, row.names = F)\n\nrio::export(tt, file = 'rawfiles/tt4.xlsx')\nrio::export(tt, file = 'rawfiles/tt4.dta')\nrio::export(tt, file = 'rawfiles/tt4.csv')\nrio::export(tt, file = 'rawfiles/tt4.txt')\nrio::export(tt, file = 'rawfiles/tt4.txt')\nreadr::write_csv(tt, 'rawfiles/tt4.txt')\n\ntt = rio::import('rawfiles/tt4.xlsx')  \ntt <- rio::import('rawfiles/tt4.xlsx')  \n\nrio::import('tt4.xlsx')  |>\n    tibble::as_tibble() ->\n    tt\n# off-topic: import and export \n#-----------\n\nsum(starwars$height, na.rm = T)\nsummary(starwars$height, na.rm = T)\n\nstarwars |> \n    group_by(species) -> \n    by_species\n\nstarwars |> \n    group_by(sex,gender) -> \n    by_sex_gender\n\n# use tally() to count the number of rows in each group\nby_species |> tally()\nby_species |> tally(sort = T)\n\nby_sex_gender |> tally(sort = TRUE)\n\nstarwars |> \n    group_by(sex, gender) |> \n    tally(sort = T)   \n\nstarwars |> \n   group_by(sex, gender) |> \n   summarise(height_mean = mean(height, na.rm = T), \n             height_max = max(height, na.rm = T),\n             height_min = min(height, na.rm = T),\n              n = n()) ->\n\n# As well as grouping by existing variables, you can group by any function of existing variables. This is equivalent to performing a mutate() before the group_by():\nbmi_breaks <- c(0, 18.5, 25, 30, Inf)\n\nstarwars |>\n    select(name, mass, height) |>\n    mutate(bmi_cat = mass / (height / 100)^2)  |> \n    mutate(bmi_cat_cut = cut(bmi_cat, breaks = bmi_breaks))  |> \n    group_by(bmi_cat_cut) |> \n    summarise(total = n(), \n              bmi_medio = mean(bmi_cat, na.rm = T), \n              bmi_max = max(bmi_cat, na.rm = T))\n\nstarwars |>\n    select(name, mass, height) |>\n    mutate(bmi_cat = cut(mass / (height / 100)^2, breaks = bmi_breaks)) |>  \n    group_by(bmi_cat) |> \n    tally()\n\nstarwars |>\n    select(name, mass, height) |>\n    mutate(bmi_cat = cut(mass / (height / 100)^2, breaks = c(0, 10, 40, Inf))) |>  \n    group_by(bmi_cat) |> \n    tally()\n\nstarwars |>\n  group_by(bmi_cat = cut(mass / (height / 100)^2, breaks = bmi_breaks)) |>  \n  tally()\n\n# group_keys: it has one row for each group and one column for each grouping variable:\nstarwars |> \n    group_by(species) |> \n    group_keys()\n\nstarwars |> \n    group_by(species) |> \n    group_keys() |> \n    print(n = 30)\n\nstarwars |> \n    group_by(species) |> \n    group_keys() |> \n    pull(species)\n\nstarwars |> \n    group_by(sex,gender) |> \n    group_keys()\n\n# group_indices: you can see which group each row belongs\nstarwars |> \n    group_by(species) |> \n    group_indices()\n\n# group_vars: if you just want the names of the grouping variables\nstarwars |> \n    group_by(sex,gender) |> \n    group_vars()\n\n# ungroup:  removing groups\nstarwars |> \n    group_by(sex, gender) |> \n    summarise(n = n())  |>\n    arrange(desc(n))\n\nstarwars |> \n    group_by(sex, gender) |>    \n    tally(sort = TRUE) ->\n    sw\n\nsw |> ungroup(sex,gender)\n\n# summarise \nstarwars |> \n    group_by(species) |> \n    summarise(qtde = n(), height = mean(height, na.rm = TRUE))\n\n# select(), rename(), and relocate() after group_by keeps groups nme\nstarwars |> \n    group_by(species) |> \n    select(mass)\n\n# ungroup to exit group_by \nstarwars |> \n    group_by(species) |> \n    ungroup(species) |> \n    select(mass)\n\n# slice in groups: we can select the first observation within each species\nstarwars |> \n    group_by(species) |> \n    relocate(species) |> \n    slice(1)\n\n# select top 2 lines of each group\nstarwars |> \n    group_by(species) |> \n    slice(1:2) |> \n    select(species, name, homeworld) |> \n    print(n = 30)\n\n# slice_min: to select the smallest n values of a variable\nstarwars |> \n    group_by(species) |> \n    dplyr::filter(!is.na(height)) |> \n    slice_min(height, n = 2) |> \n    select(height, name, species, homeworld) |> \n    print(n = 30)\n\n# cur_group_id\nstarwars |> \n    group_by(species) |> \n    arrange(species) |> \n    select(name, species, homeworld) |> \n    mutate(id = cur_group_id())\n\n\n# ------------------------------\n## Two-table verbs\n#\n# Wickham and Grolemund (2016) R for data science\n# CHAPTER 10 Relational Data with dplyr\n#\n# https://dplyr.tidyverse.org/articles/two-table.html\n# https://bookdown.org/roy_schumacher/r4ds/relational-data.html\n\nlibrary(nycflights13)\n\ndata(flights)           # nycflights13 example\ndata(airlines)          # nycflights13 example\ndata(weather)           # nycflights13 example\ndata(planes)            # nycflights13 example\ndata(airports)          # nycflights13 example\n\nflights\n\n# Drop unimportant variables so it's easier to understand the join results\nflights |> \n    select(year:day, hour, origin, dest, tailnum, carrier) -> \n    flights2\n\nairlines |> print(n = Inf)\n\nnames(airlines);names(flights2)\n\nmerge(flights2, airlines) |> \n    as_tibble() -> \n    a\n\n# results\nleft_join(flights2, airlines)\n\nflights2 |> \n    left_join(airlines) \n\nflights2 |> \n    left_join(weather) -> \n    a\n\nleft_join(flights2, weather)\n\nflights2 |> left_join(weather) |> glimpse()\n\nflights2 |> left_join(planes, by = \"tailnum\")\nflights2 |> left_join(planes, by = \"tailnum\") |> glimpse()\n\nflights2 |> left_join(airports, c(\"dest\" = \"faa\"))\nflights2 |> left_join(airports, c(\"dest\" = \"faa\")) |> glimpse()\n\n# Types of join\n# \ndf1 <- tibble(x = c(1, 2), y = 2:1)\ndf2 <- tibble(x = c(3, 1), a = 10, b = \"a\")\n\ndf1 |> left_join(df2)\ndf1 |> right_join(df2)\ndf1 |> inner_join(df2)\ndf1 |> full_join(df2)\n\ndf1 <- tibble(x = c(1, 2, 3, 3, 4), y = 1)\ndf2 <- tibble(x = c(1, 3, 3), a = c(10, 20, 30), b = c('a', 'b', 'c'))\n\ndf1 |> left_join(df2)\ndf1 |> right_join(df2)\ndf1 |> inner_join(df2)\ndf1 |> full_join(df2)\n\ndf1 |>\n    distinct(.keep_all = TRUE) |>\n    left_join(df2) \n\nflights2 |> count(carrier)\n    \nflights2 |> \n    group_by(carrier) |> \n    tally(sort = T)\n\nflights2 |> \n    left_join(airlines) |>     \n    group_by(name, month) |> \n    summarise(qtde = n()) |> \n    arrange(month, desc(qtde))\n\n\n\n# ------------------------------\n# Part 3: tidyr basic\n\n# Livro PDF\n# Wickham and Grolemund (2016) R for data science\n# CHAPTER 9 Tidy Data with tidyr\n\n# Livro digital\n# CHAPTER 12 Tidy Data \n# https://bookdown.org/roy_schumacher/r4ds/tidy-data.html\n\n# The goal of tidyr is to help you create tidy data. Tidy data is data where:\n\n#     Every column is variable.\n#     Every row is an observation.\n#     Every cell is a single value.\n\n# Each dataset shows the same values of four variables, country,\n# year, population, and cases (tuberculosis), but each dataset organizes the values in a\n# different way\n\ntable1 # only tidy\ntable2\ntable3\ntable4a\ntable4b\n\n## pivot_longer(), antigo gather()\n\ntable4a\n\ntable4a |> \n  gather(`1999`, `2000`, key = \"year\", value = \"cases\")\n\n# nova nomeclatura\ntable4a |> \n    pivot_longer(c(`1999`, `2000`), \n                 names_to = \"year\", \n                 values_to = \"cases\") ->\n        t4a\n    \n\ntable4b |> \n    pivot_longer(c(`1999`, `2000`), \n                 names_to = \"year\", \n                 values_to = \"population\") ->\n    t4b\n\ndplyr::left_join(t4a, t4b) \n\n\n## pivot_wider(), antigo spreading()\n\ntable2\n\nspread(table2, key = type, value = count)\n\ntable2 |>\n    pivot_wider(names_from = 'type', \n                values_from = 'count')\n\n## separate \n# pulls apart one column into multiple columns, by splitting wherever a separator character appears\n\ntable3 |> \n    separate(rate, into = c(\"cases\", \"population\"))\n\ntable3 |> \n    separate(rate, into = c(\"cases\", \"population\"), sep = \"/\")\n\ntable3 |> \n    separate(rate, into = c(\"cases\", \"population\"), sep = \"/\", convert = T)\n\ntable3 |> \n    separate(year, into = c(\"century\", \"year\"), sep = 2)\n\n## separate_rows\n\ntable3\n\ntable3 |> \n    separate_rows(rate, sep = \"/\")\n\nseparate_rows(table3, rate, sep = \"/\")\n\n## unite\n# it combines multiple columns into a single column\n\ntable5 |> \n    unite(new, century, year)\n\ntable5 |> \n    unite(new, century, year, sep = '') |>\n    dplyr::mutate(new = as.numeric(new)) \n\n## missing values\n\n# Surprisingly, a value can be missing in one of two possible ways:\n#     Explicitly, i.e. flagged with NA.\n#     Implicitly, i.e. simply not present in the data.\n\nstocks <- tibble(\n  year   = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),\n  qtr    = c(   1,    2,    3,    4,    2,    3,    4),\n  return = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)\n)\n\nstocks\n# There are two missing values in this dataset:\n#     The return for the fourth quarter of 2015 is explicitly missing, because the cell where its value should be instead contains NA.\n#     The return for the first quarter of 2016 is implicitly missing, because it simply does not appear in the dataset.\n\nstocks |> \n  complete(year, qtr)\n\n# fill()\n# It takes a set of columns where you want missing values to be replaced by the most recent \n# non-missing value (sometimes called last observation carried forward)\nreatment <- tribble(\n  ~ person,           ~ treatment, ~response,\n  \"Derrick Whitmore\", 1,           7,\n  NA,                 2,           10,\n  NA,                 3,           9,\n  \"Katherine Burke\",  1,           4\n)\n\nreatment\n\nreatment |> \n    fill(person)\n\n# replace_na()\n# Replace NAs with specified values\n\ndf <- tibble(x = c(1, 2, NA), y = c(\"a\", NA, \"b\"))\n\ndf |> \n    replace_na(list(x = 0, y = \"unknown\"))\n\ndf |> \n    dplyr::mutate(x = replace_na(x, 0))\n\ndf |> \n    dplyr::mutate(x = replace_na(x, 0), \n                  y2 = replace_na(y, 'unknown'))\n\n# drop_na()\n# Drop rows containing missing values\n\ndf |> drop_na()\ndf |> drop_na(x)\n\nvars <- \"y\"\ndf |> drop_na(x, any_of(vars))\n\nvars2 <- c(\"y\",'d')\ndf |> drop_na(x, any_of(vars2))\n\n## estudo de caso\n# The tidyr::who dataset contains tuberculosis (TB) cases broken down by year, \n# country, age, gender, and diagnosis method. The data comes from the 2014 \n# World Health Organization Global Tuberculosis Report, available at http://www.who.int/tb/country/data/download/en\nwho\n\nwho |>\n    pivot_longer(new_sp_m014:newrel_f65, \n                 names_to = 'code', \n                 values_to = 'value', \n                 values_drop_na = T) |> \n    mutate(code = stringr::str_replace(code, \"newrel\", \"new_rel\")) |>\n    separate(code, c(\"new\", \"var\", \"sexage\")) |>\n    # select(-new, -iso2, -iso3) |>\n    separate(sexage, c(\"sex\", \"age\"), sep = 1)\n\n\n\n# ------------------------------\n# Part 4: dplyr advanced\n\n# across()\n# case_when()\n# rowwise()\n\n# --------\n## across()\niris |>\n    tibble::as_tibble() ->\n    iris_tbl\n\n# duas variáveis específicas\niris_tbl |> \n    mutate(across(c(Sepal.Length, Sepal.Width), round))\n\n# variáveis por posição\niris_tbl |>\n    mutate(across(c(1, 2), round))\n\n# intervalor misto\niris_tbl |>\n    mutate(across(1:Sepal.Width, round))\n\niris_tbl |>\n    mutate(across(where(is.double) & !c(Petal.Length, Petal.Width), round))\n\n# A purrr-style formula\niris_tbl |>\n    group_by(Species) |>\n    summarise(across(starts_with(\"Sepal\"), ~ mean(.x, na.rm = TRUE)))\n\n# A named list of functions\niris_tbl |>\n    group_by(Species) |>\n    summarise(across(starts_with(\"Sepal\"), list(mean = mean, sd = sd)))\n\n# Use the .names argument to control the output names\niris_tbl |>\n    group_by(Species) |>\n    summarise(across(starts_with(\"Sepal\"), mean, .names = \"mean_{.col}\"))\n\niris_tbl |>\n    group_by(Species) |>\n    summarise(across(starts_with(\"Sepal\"), list(mean = mean, sd = sd), .names = \"{.col}.{.fn}\"))\n\n# When the list is not named, .fn is replaced by the function's position\niris_tbl |>\n    group_by(Species) |>\n    summarise(across(starts_with(\"Sepal\"), list(mean, sd), .names = \"{.col}.fn{.fn}\"))\n\niris_tbl |>\n    group_by(Species) |>\n    summarise(across(starts_with(\"Sepal\"), list(mean, sd), .names = \"nova_var_{.col}_{.fn}\"))\n\n# across() returns a data frame, which can be used as input of another function\ndf <- data.frame(\n                 x1  = c(1, 2, NA), \n                 x2  = c(4, NA, 6), \n                 y   = c(\"a\", \"b\", \"c\"))\n\ndf |>\n    mutate(x_complete = complete.cases(across(starts_with(\"x\"))))\n\ndf |>\n    filter(complete.cases(across(starts_with(\"x\"))))\n\n# if_any() and if_all() \niris_tbl |>\n    filter(if_any(ends_with(\"Width\"), ~ . > 4))\n\niris_tbl |>\n    filter(if_all(ends_with(\"Width\"), ~ . > 2))\n\n# --------\n# case_when()\n\nx <- 1:50\n\n4 %% 2\n5 %% 2\n10 %% 3\n11 %% 3\n12 %% 3\n\ncase_when(\n    x %% 35 == 0 ~ \"fizz buzz\",\n    x %% 5 == 0 ~ \"fizz\",\n    x %% 7 == 0 ~ \"buzz\",\n    TRUE ~ as.character(x)\n)\n\n# Like an if statement, the arguments are evaluated in order, so you must\n# proceed from the most specific to the most general. This won't work:\ncase_when(\n    TRUE ~ as.character(x),\n    x %%  5 == 0 ~ \"fizz\",\n    x %%  7 == 0 ~ \"buzz\",\n    x %% 35 == 0 ~ \"fizz buzz\"\n)\n\n# If none of the cases match, NA is used:\ncase_when(\n    x %%  5 == 0 ~ \"fizz\",\n    x %%  7 == 0 ~ \"buzz\",\n    x %% 35 == 0 ~ \"fizz buzz\"\n)\n\n# Note that NA values in the vector x do not get special treatment. If you want\n# to explicitly handle NA values you can use the `is.na` function:\nx[2:4] <- NA_real_\n\ncase_when(\n    x %% 35 == 0 ~ \"fizz buzz\",\n    x %% 5 == 0 ~ \"fizz\",\n    x %% 7 == 0 ~ \"buzz\",\n    is.na(x) ~ \"nope\",\n    TRUE ~ as.character(x)\n)\n\n# All RHS values need to be of the same type. Inconsistent types will throw an error.\n# This applies also to NA values used in RHS: NA is logical, use\n# typed values like NA_real_, NA_complex, NA_character_, NA_integer_ as appropriate.\ncase_when(\n    x %% 35 == 0 ~ NA_character_,\n    x %% 5 == 0 ~ \"fizz\",\n    x %% 7 == 0 ~ \"buzz\",\n    TRUE ~ as.character(x)\n)\ncase_when(\n    x %% 35 == 0 ~ 35,\n    x %% 5 == 0 ~ 5,\n    x %% 7 == 0 ~ 7,\n    TRUE ~ NA_real_\n)\n\n# case_when() evaluates all RHS expressions, and then constructs its\n# result by extracting the selected (via the LHS expressions) parts.\n# In particular NaNs are produced in this case:\ny <- seq(-2, 2, by = .5)\n\ncase_when(\n    y >= 0 ~ sqrt(y),\n    TRUE   ~ y\n)\n\n# This throws an error as NA is logical not numeric\ntry(case_when(\n    x %% 35 == 0 ~ 35,\n    x %% 5 == 0 ~ 5,\n    x %% 7 == 0 ~ 7,\nTRUE ~ NA\n))\n\n# case_when is particularly useful inside mutate when you want to\n# create a new variable that relies on a complex combination of existing\n# variables\nstarwars |>\n    select(name:mass, gender, species) |>\n    mutate(\n      type = case_when(\n        height > 200 | mass > 200 ~ \"large\",\n        species == \"Droid\"        ~ \"robot\",\n        TRUE                      ~ \"other\"\n      )\n    )\n\n\n# `case_when()` ignores `NULL` inputs. This is useful when you'd\n# like to use a pattern only under certain conditions. Here we'll\n# take advantage of the fact that `if` returns `NULL` when there is\n# no `else` clause:\n\n\n# --------\n# rowwise()\n\nfruits <- tribble(\n  ~\"fruit\", ~\"height_1\", ~\"height_2\", ~\"height_3\", ~\"width\", ~\"weight\",\n  \"Banana\", 4, 4.2, 3.5, 1, 0.5,\n  \"Strawberry\", 1, .9, 1.2, 1, .25,\n  \"Pineapple\", 18, 17.7, 19.2, 6, 3)\n\nfruits\n\n# mean across all values in all rows\nfruits |> \n    mutate(height_mean = mean(c(height_1, height_2, height_3))) \n\n# válido pois as frutas não se repetem, mas perigoso\nfruits |> \n    group_by(fruit) |>\n    mutate(height_mean = mean(c(height_1, height_2, height_3))) \n\n# mean across all values in each row\nfruits |> \n    rowwise(fruit) |> \n    mutate(height_mean = mean(c(height_1, height_2, height_3)))\n\n# per-row summary statistics\ndf <- tibble(id = 1:6, w = 10:15, x = 20:25, y = 30:35, z = 40:45)\ndf\n\ndf |> \n    rowwise(id) ->\n    rf\n\n# mutate to add new column for each row\nrf |> \n    mutate(total = sum(c(w, x, y, z)))\n\n# wrong way\ndf |> \n    mutate(total = sum(c(w, x, y, z)))\n\n# summarize without mutate\nrf |> \n    summarise(total = sum(c(w, x, y, z)), .groups= \"drop\")\n\n# with across()\nrf |> \n    mutate(total = sum(c_across(w:z)))\n\n# ‘c_across()’ is designed to work with ‘rowwise()’ to make it easy to perform row-wise aggregations.\nrf |>   \n    mutate(total = sum(c_across(where(is.numeric))))\n\n# If we want to use our fruits example... \nfruits |> \n    rowwise(fruit) |> \n    mutate(height_mean = mean(c_across(contains(\"height\"))))\n\nrf |>                                           #our row-wise data frame\n    mutate(total = sum(c_across(w:z))) |>       #total each row\n    ungroup() |>                                # ungroup the rows\n    mutate(across(w:z, ~ .x / total))           # the .x represents each column\n\n\n# ------------------------------\n# Part 5: tidyr advanced\n#\n# Nested data\n\n# A nested data frame is a data frame where one (or more) columns is a \n# list of data frames. You can create simple nested data frames by hand:\n\n# create\n\nstorms |> count(name, sort = T)\n\nstorms |> \n    group_by(name) |>\n    nest() ->\n    storms_n\n\nstorms_n\nstorms_n$idade  <- 1:214\n\nstorms_n |> \n    dplyr::relocate(name, idade) \n\nstorms |> \n    nest(data = c(year:long)) ->\n    storms_n\n\n# reshape nested data\n\n# unnest() Turn each element of a list-column into a row\nstorms_n |> unnest(data)\n\n# unnest_longer() Turn each element of a list-column into a row\nstarwars |>\n    select(name, films) |>\n    unnest_longer(films)\n\n# unnest_wider() Turn each element of a list-column into a regular column\nstarwars |> \n    select(name, films) |>\n    unnest_wider(films)\n\n# hoist()  Selectively pull list components out into their own top-level columns\nstarwars |>\n    select(name, films) |>\n    hoist(films, first_film = 1, second_film = 2)\n\n# transform nested data\n\n# dplyr::rowwise() \nstorms_n |>\n    rowwise() |>\n    mutate(n = nrow(data))\n\nstorms_n |>\n    rowwise() |>\n    mutate(n = list(dim(data)))\n\nstorms_n |>\n    rowwise() |>\n    mutate(n = list(dim(data))) |>\n    unnest_longer(n) |>\n    filter(name == 'Amy') |>\n    unnest_longer(data) ->\n    amy\n\nstarwars |>\n    rowwise() |> \n    mutate(transport = list(append(vehicles, starships))) |>\n    select(name, transport) |>\n    unnest_longer(transport)\n\n# -----\n## Rectangling \n# Rectangling is the art and craft of taking a deeply nested list \n# (often sourced from wild caught JSON or XML) and taming it into a \n# tidy data set of rows and columns. \n\n# https://tidyr.tidyverse.org/articles/rectangle.html\n\n# tópico bonus\n# útil quando os alunos estudarem lista \n# ótimo combo com o pacote purrr\n\nlibrary(repurrrsive) \n\nusers <- tibble(user = gh_users)\n\nusers[[1]]\n\nnames(users$user[[1]])\n\nusers |> unnest_wider(user)\n\nusers |> \n    hoist(user, \n          followers = \"followers\", \n          login = \"login\", \n          url = \"html_url\")\n\n\nrepos <- tibble(repo = gh_repos)\n\nrepos[[1]]\n\nrepos |> \n    unnest_longer(repo) ->\n    repos\n\nrepos |> \n    hoist(repo,\n          login = c(\"owner\", \"login\"), \n          name = \"name\", \n          homepage = \"homepage\", \n          watchers = \"watchers_count\")\n\nrepos |> \n    hoist(repo, owner = \"owner\") |> \n    unnest_wider(owner)\n\ntibble(repo = gh_repos) |> \n    unnest_auto(repo) |>\n    unnest_auto(repo)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}